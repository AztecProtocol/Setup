#include <libff/algebra/curves/alt_bn128/alt_bn128_pp.hpp>

#include <stdio.h>

#include <setup/setup.cpp>
#include <verify/verifier.hpp>

#include <deepstate/DeepState.hpp>

#define TRANSCRIPT_PATH "../setup_db"

using namespace deepstate;


class EntryPoint: public Test {
  public:

	size_t num_g1_points;
	size_t num_g2_points;

	size_t progress;

	// each test we run requires interacting with actual transcripts, so this
	// setup constructor ensures that we create a temporary transcript path.
    void SetUp(void)
	{
		LOG(TRACE) << "Initializing setup for entry point test";

		std::string transcript_dir(TRANSCRIPT_PATH);

		// function should check inodes regardless of filetype
		if (!streaming::is_file_exist(transcript_dir))
		{
			LOG(ERROR) << "Transcript directory doesn't exist.";
		}

		// if tests run simultaneous, kill if transcript dir and transcript 0 exists
		std::string _zero_transcript(TRANSCRIPT_PATH);
		_zero_transcript += "/transcript0_out.dat";
		if (streaming::is_file_exist(_zero_transcript))
		{
			LOG(TRACE) << "Transcript path exists and is populated.";
			Test();
		}

		libff::alt_bn128_pp::init_public_params();

		num_g1_points = DeepState_IntInRange(1, 250000);
		num_g2_points = DeepState_IntInRange(1, 100);

        // emulates simplified functionality of `run_setup` without unused/uncovered functionality.
		// we will force the test to use a simulated participant.

		std::vector<char> checksums;
		size_t num = 0;
		std::string filename = getTranscriptInPath(transcript_dir, num);

		while (streaming::is_file_exist(filename))
		{
			std::vector<char> checksum = streaming::read_checksum(filename);
			checksums.insert(checksums.end(), checksum.begin(), checksum.end());
			++num;
			filename = getTranscriptInPath(transcript_dir, num);
		}

		char checksum_of_checksums[checksum::BLAKE2B_CHECKSUM_LENGTH] = {0};
		checksum::create_checksum(&checksums[0], checksums.size(), &checksum_of_checksums[0]);

		Fr simulated_secret = utils::convert_buffer_to_field_element<Fr>(&checksum_of_checksums[0], checksum::BLAKE2B_CHECKSUM_LENGTH);
		Secret<Fr> multiplicand(simulated_secret);

		if (num_g1_points > 0)
		{
			compute_initial_transcripts(transcript_dir, num_g1_points, num_g2_points, \
				POINTS_PER_TRANSCRIPT, multiplicand, progress);
		}
		else
		{
			size_t num = 0;
			std::string filename = getTranscriptInPath(transcript_dir, num);
			while (streaming::is_file_exist(filename))
			{
				compute_existing_transcript(transcript_dir, num, multiplicand, progress);
				filename = getTranscriptInPath(transcript_dir, ++num);
			}
		}
	}

	void TearDown(void) {
		LOG(TRACE) << "Tearing down setup for entry point test";
		// clear setup_db/ or other transcript path
	}
};


/* EntryPoint_ValidateSetup
 *
 * 		Test fixture for validating points parsed out of written transcript
 *		file from fixture SetUp constructor. Equivalent to verify-set functionality,
 *		but with additional sanity checks.
 */
TEST_F(EntryPoint, ValidateSetup)
{
	std::vector<G1> g1_x;
	std::vector<G2> g2_x;

	streaming::Manifest manifest;

	std::string transcript_path = TRANSCRIPT_PATH;
	transcript_path += "/transcript0_out.dat";

	// check by reading out points and validating
	streaming::read_transcript_g1_points(g1_x, transcript_path, 0, 1);
	streaming::read_transcript_g2_points(g2_x, transcript_path, 0, 1);
	ASSERT(g1_x.size() || g2_x.size())
		<< "Missing either G1 or G2 zero point.";
	ASSERT(g1_x.size() == num_g1_points)
		<< "Number of G1 points parsed not equal to original size " << num_g1_points;
	ASSERT(g2_x.size() == num_g2_points)
		<< "Number of G2 points parsed not equal to original size " << num_g2_points;

	// check by validating manifest contents
	streaming::read_transcript_manifest(manifest, transcript_path);
	ASSERT(manifest.total_g1_points == num_g1_points)
		<< "Manifest contains wrong total number of G1 points.";
	ASSERT(manifest.total_g2_points == num_g2_points)
		<< "Manifest contains wrong total number of G2 points.";
}


/* EntryPoint_VerifyFirst
 *
 * 		Test fixture for verifying the first transcript generated by a first participant
 *		in trusted setup. Includes functionality from ValidateSetup in order to enforce
 *		necessary sanity checks and maximize test coverage.
 */
TEST_F(EntryPoint, VerifyFirst)
{
    std::string transcript_path = TRANSCRIPT_PATH;
	transcript_path += "/transcript0_out.dat";

	ASSERT(streaming::is_file_exist(transcript_path))
		<< "Transcript not found in path: " << transcript_path;

    streaming::Manifest manifest;

    std::vector<G1> g1_x;
    std::vector<G2> g2_x;
    std::vector<G1> g1_0_0;
    std::vector<G2> g2_0_0;
    std::vector<G1> g1_x_previous;
    std::vector<G2> g2_y;

    // Read first points from transcript 0.
    streaming::read_transcript_g1_points(g1_0_0, transcript_path, 0, 1);
    streaming::read_transcript_g2_points(g2_0_0, transcript_path, 0, 1);

	ASSERT(g1_0_0.size() || g2_0_0.size())
		<< "Missing either G1 or G2 zero point.";

    streaming::read_transcript_manifest(manifest, transcript_path);

    // If we are transcript 0 we need to add the generator point to the beginning of the series.
    // This allows validating a single point as there will be at least 2 in the series.
    g1_x.push_back(G1::one());
    g2_x.push_back(G2::one());

    // First participant, first transcript. Discard our g2^y point.
	ASSERT(manifest.transcript_number == 0)
		<< "Transcript read not an initial transcript from first participant.";

    streaming::read_transcript(g1_x, g2_x, manifest, transcript_path);
    g2_x.pop_back();

	LOG(TRACE) << "Verifying and validating transcripts";
    validate_transcript(g1_0_0[0], g2_0_0[0], g1_x, g2_x, g1_x_previous, g2_y);
	LOG(TRACE) << "Transcript is valid";
}


/* EntryPoint_VerifyPrevious
 *
 * 		Test fixture for verification of a current transcript and manifest
 *		as well as validating against previous and transcript 0.
TEST_F(EntryPoint, DISABLED_VerifyPrevious)
{
	// initialize paths from common transcript path
    std::string transcript = TRANSCRIPT_PATH;
	transcript += "/transcript1_out.dat";
	std::string previous_transcript(TRANSCRIPT_PATH);
	previous_transcript += "/transcript0_out.dat";
	std::string first_transcript(TRANSCRIPT_PATH);
	first_transcript += "/transcript0_out.dat";

	ASSERT(streaming::is_file_exist(transcript))
		<< "Transcript not found in path: " << transcript;
	ASSERT(streaming::is_file_exist(previous_transcript))
		<< "Previous transcript not found in path: " << previous_transcript;
	ASSERT(streaming::is_file_exist(first_transcript))
		<< "Transcript 0 not found in path: " << first_transcript;

	streaming::Manifest manifest;
    streaming::Manifest previous_manifest;

    std::vector<G1> g1_x;
    std::vector<G2> g2_x;
    std::vector<G1> g1_0_0;
    std::vector<G2> g2_0_0;
    std::vector<G1> g1_x_previous;
    std::vector<G2> g2_y;

    // Read first points from transcript 0.
    streaming::read_transcript_g1_points(g1_0_0, first_transcript, 0, 1);
    streaming::read_transcript_g2_points(g2_0_0, first_transcript, 0, 1);

	ASSERT(g1_0_0.size() || g2_0_0.size())
		<< "Missing either G1 or G2 zero point.";

    streaming::read_transcript_manifest(manifest, transcript);
    streaming::read_transcript_manifest(previous_manifest, previous_transcript);
    validate_manifest(previous_manifest, manifest);

    // If this transcript and previous transcript are 0, we are going to check this transcript was built
    // on top of the previous participants using the g2^y and previous g1_x points.
    if (manifest.transcript_number == 0 && previous_manifest.transcript_number == 0)
    {
        streaming::read_transcript_g1_points(g1_x_previous, previous_transcript, 0, 1);
        streaming::read_transcript(g1_x, g2_x, manifest, transcript);
        // Extract g2_y point from this transcript.
        g2_y.push_back(g2_x.back());
        g2_x.pop_back();
    }
    else
    {
        // Read the last points from the previous transcript to validate the sequence.
        // Second to last g2 point if the previous transcript is 0, due to g2^y being tacked on.
        streaming::read_transcript_g1_points(g1_x, previous_transcript, -1, 1);
        size_t from_g2_end = previous_manifest.transcript_number == 0 ? -2 : -1;
        streaming::read_transcript_g2_points(g2_x, previous_transcript, from_g2_end, 1);
        streaming::read_transcript(g1_x, g2_x, manifest, transcript);
    }

	LOG(TRACE) << "Verifying and validating transcripts";
    validate_transcript(g1_0_0[0], g2_0_0[0], g1_x, g2_x, g1_x_previous, g2_y);
	LOG(TRACE) << "Transcript is valid";
}
*/
